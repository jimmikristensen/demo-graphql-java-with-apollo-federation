#+title: GraphQL Federation Demo (Java + Apollo Gateway)
#+author: Jimmi

The purpose of this demo is to demonstrate how it is possible to support GraphQL Schema Federation with the Micronaut framework.

This repository presents a demo that composes the distinct schemas of Java (Micronaut) GraphQL servers into a federated data graph with Apollo Gateway.

The demo application is a fake service that is able to serve information on movies and series from a few downstream GraphQL servers through an Apollo Gateway (Federated gateway). 
The diagram below illustrates the architecture of this demo application.

Each downstream Java (Micronaut) service is responsible of exposing its context through the service destinct GraphQL schema:

- *Entity Service* serves information on movies and series through its schema
  - [[https://github.com/jimmikristensen/demo-graphql-java-with-apollo-federation/tree/main/entity_service][entity_service]]
- *Search Service* handles searches on movies and series through its schena
  - [[https://github.com/jimmikristensen/demo-graphql-java-with-apollo-federation/tree/main/search_service][search_service]]
- *Image Service* serves images belonging to either a movie, series or a background of a deck through its schema
  - [[https://github.com/jimmikristensen/demo-graphql-java-with-apollo-federation/tree/main/image_service][image_service]]
- *Deck Service* serves collections of movies and series through its schema
  - [[https://github.com/jimmikristensen/demo-graphql-java-with-apollo-federation/tree/main/deck_service][deck_service]]

[[https://raw.githubusercontent.com/jimmikristensen/demo-graphql-java-with-apollo-federation/main/Micronaut%20GraphQL%20Demo.jpeg]]

* Versions used in this demo

- Java: 14
- Micronaut: 2.0.3
- Node: 14.16
- npm: 6.14.11 

* Preparing your GraphQL server for federation

** Start by setting up a regular GraphQL Java server

/I am going to assume you already are familiar with setting up a regular GraphQL server with Micronaut, if not do that first.
Below are useful links for the documentation and an example application:/

- [[https://micronaut-projects.github.io/micronaut-graphql/snapshot/guide/index.html][Micronaut GraphQL Integration]]
- [[https://github.com/micronaut-projects/micronaut-graphql/tree/master/examples/hello-world-java][Micronaut GraphQL Hello World Java example]]
- [[https://www.graphql-java.com/documentation/v16/][GraphQL Java Documentation]]

** Federate your GraphQL Java server

/For a general introduction to Apollo Federation I suggest you read [[https://www.apollographql.com/docs/federation/][Introduction to Apollo Federation]]/

As stated in the documentation ([[https://github.com/apollographql/federation-jvm][Apollo Federation on the JVM]]), for this you need to add a dependency to /federation-graphql-java-support/ in the *build.gradle* file:

#+begin_src java
dependencies {
    implementation 'com.apollographql.federation:federation-graphql-java-support:<add_the_newest_version>'
}
#+end_src

In the documentaion [[https://micronaut-projects.github.io/micronaut-graphql/latest/guide/][Micronaut GraphQL Integration]] you were instructed to create a /GraphQLFactory/ containing 4 steps:

#+begin_src java
@Factory 
public class GraphQLFactory {

    @Bean
    @Singleton
    public GraphQL graphQL(ResourceResolver resourceResolver, HelloDataFetcher helloDataFetcher) {

        SchemaParser schemaParser = new SchemaParser();
        SchemaGenerator schemaGenerator = new SchemaGenerator();

        // Parse the schema. (1)
        TypeDefinitionRegistry typeRegistry = new TypeDefinitionRegistry();
        typeRegistry.merge(schemaParser.parse(new BufferedReader(new InputStreamReader(
                resourceResolver.getResourceAsStream("classpath:schema.graphqls").get()))));

        // Create the runtime wiring. (2)
        RuntimeWiring runtimeWiring = RuntimeWiring.newRuntimeWiring()
                .type("Query", typeWiring -> typeWiring
                        .dataFetcher("hello", helloDataFetcher))
                .build();

        // Create the executable schema. (3)
        GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeRegistry, runtimeWiring);

        // Return the GraphQL bean. (4)
        return GraphQL.newGraphQL(graphQLSchema).build();
    }
}
#+end_src

Converting that /GraphQLFactory/ to support federation is quite similar to the above:

1) Parse the schema file residing in the classpath, e.g. in the resources dir
2) Create the runtime wiring where you declare your data fetchers for the corresponding fields
3) *But instead of* using /schemaGenerator.makeExecutableSchema/ to generate a /GraphQLSchema/, you use /Federation.transform/ like below:
4) Return the /GraphQLSchema/ with federation support instead

Example from [[https://github.com/jimmikristensen/demo-graphql-java-with-apollo-federation/blob/main/entity_service/src/main/java/entity/GraphQLFactory.java][entity_service]]:

#+begin_src java
// Resolve entity types (A)
GraphQLSchema graphQLSchema = Federation.transform(typeRegistry, runtimeWiring).resolveEntityType(env -> {
    final Object src = env.getObject();
    if (src instanceof Search) {
        return env.getSchema().getObjectType("Search");
    }
    return null;

// Decleare datafetcher for _entities (B)
}).fetchEntities(env -> env.<List<Map<String, Object>>>getArgument(_Entity.argumentName)
    .stream()
    .map(values -> {
        if ("Search".equals(values.get("__typename"))) {
            final Object guids = values.get("guids");
            if (guids instanceof List) {
                return new Search(entityDatastore.lookupEntityIds(convertObjectToIntegerList(guids)));
            }
        }
        return null;
    }
).collect(Collectors.toList())).build();

// Return the federation enabled schema (C)
return GraphQL.newGraphQL(graphQLSchema).instrumentation(new CustomInstrumentation()).build();
#+end_src

As the Entity service extends the Search object declared in the [[https://github.com/jimmikristensen/demo-graphql-java-with-apollo-federation/blob/main/search_service/src/main/resources/schema.graphqls][Search]] service it therefore declares a type with the *@key* annotation in its [[https://github.com/jimmikristensen/demo-graphql-java-with-apollo-federation/blob/main/entity_service/src/main/resources/schema.graphqls][schema.graphql]] file.
All types annotated with *@key* will be part of the *_Entity* union type, and reachable through:

#+begin_src json
query { _entities(representations: [Any!]!) { â€¦ } }
#+end_src

Before calling the /build()/ method, we will also need to provide:

A) A /TypeResolver/ for *_Entity* using /SchemaTransformer#resolveEntityType(TypeResolver)/
   - We use the /TypeResolutionEnvironment/ to get the specific source object that needs to be resolved
   - If the source object is an instance of /Search/ we return the /GraphQLObjectType/ of Search from the schema
B) A /DataFetcher/ or /DataFetcherFactory/ for *_entities* using /SchemaTransformer#fetchEntities(DataFetcher|DataFetcherFactory)/
   - This time we use the /DataFetchingEnvironment/ to get the *__typename* to find out which type we need to find a data fetcher for
   - If that *__typename* matches Search we use the /DataFetchingEnvironment/ to get the *external* key value from the Search service, in this case *guids*
   - Lastly, we return a *Search* object populated with the list of *Entities*

* Running the demo

You can run the demo using docker-compose or by starting each application your self.

** Using docker-compose

Build each of the Java applications:

#+begin_src shell
cd entity_service
./gradlew clean build
#+end_src

Do this for each of the Java applications (entity_service, search_service, image_service, deck_service).





# A line comment

Example of an @@comment:inline@@ comment.

Inline comments are used for end of line comments. @@comment:~#~ won't
work@@ Since # only only works if preceeded by a newline follow by
whitespace.

#+begin_comment
This is a block comment.
It can span multiple line.
As well as other markup.
#+begin_src emacs-lisp
(+ 1 2)
#+end_src
#+end_comment

* A top level headline
** COMMENT This section and subsections are commented out
*** This headline inherits the =COMMENT= keyword
This text is commented out
** This headline is not commented
This text will be exported and code blocks will run.
